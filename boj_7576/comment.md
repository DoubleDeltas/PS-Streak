# 백준 7576번: 토마토
_Code: 20220414, Comment: 20220414, Last Edit: -_

## 들어가는 말
 오늘은 다시 CLASS 문제로 돌아왔다. 이산수학, 자료구조 시간에 배운 틀에 박힌 DFS에다 약간의 응용을 섞은 문제. 필자는 해결법을 바로 떠올려 내고는 데자와 한 캔과 함께 잠시 바람을 쐰 뒤, 바로 코딩에 들어갈 수 있었다.

 개인적으로 PS를 할 때 힌트나 질문란은 안 보려고 했지만, 어쩌다보니 살짝 보게 되었음을 고백한다. 나쁜 습관이다. 스스로 머리를 싸매며 더 고통받아보자.

## 본문
 이 문제의 해법을 찾기 위한 아이디어는 다음에서 비롯된다.
 
 ![](img/1.png)

 기존의 DFS는 '하나의 점'을 기준으로 범위를 한 칸씩 넓히며 탐색한다.
 
 ![](img/2.png)
 
 여러 점을 시점으로 하더라도 방법은 똑같을 것이다. 그러나, 우리는 DFS가 완료된 후의 깊이, 즉 시점들로부터의 거리 중 최댓값을 알아야 한다. 물론 새로운 데이터를 큐에 넣을 때 탐색 중이던 깊이를 쌍으로 묶어 같이 주어도 되겠지만, 그렇게 되면 '깊이'라는 데이터에 중복성이 너무 짙다. 다른 방법을 생각해보면, 간단한 방법이 하나 더 있다.

 한 단계, 즉 같은 깊이의 DFS를 마칠 때마다 잠시 쉬는 것이다. 이를 위해선, 쉬는 동안 보관해 두기 위한 큐가 따로 필요하다. 코드에서는 이를 `tmpq`(temporary queue)라는 변수로 표현했다.

 탐색이 이루어진 후의 이웃 노드의 정보는 메인 큐(`q`)에 바로 저장되지 않고, `tmpq`에 임시로 저장된다. 그러면 서로 같은 단계들의 탐색이 끝나면 `q`는 비게 될 것이다. 이 때를 트리거로 카운터(`cnt`)를 올리고 임시로 저장해 두었던 노드들을 `q`로 옮겨 작업을 계속하는 것이다.
 
 몇 번의 시행착오가 있었지만, 아이디어 자체는 틀리지 않았다.

## 나가는 말
며칠 연속으로 골드 문제를 풀다 보니 실력이 늘었다고 착각이 들기도 한다. 프로그래머는 겸손해야 한다는 것을 잊지 말자.