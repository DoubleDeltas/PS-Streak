# 백준 14500: 테트로미노
_Code: 20220411, Comment: 20220411, Last Edit: -_

## 들어가는 말
 4월은 죽음의 달이다. 인공지능 강의와 자잘하게 들어오는 과제, 팀플, 그리고 의뢰받은 마인크래프트 개발과 TRPG, 그리고 중간고사까지 화룡점정을 찍는다. 이런 상황이니 가끔 스트릭이 끊기는 것은 당연한 걸까? 그래도 아직 solved.ac의 스트릭은 끊기지 않았다. (브론즈 문제로 땜빵 치고 있다. ALL SOLVE 배너는 못 참지)
 
 게으른 주제에 거절을 못하는 나 자신이 밉다. 반성의 의미로, 노가다 골드 문제를 풀었다.

## 본문

### 1. 문제 분석

![](img/1.png)

 스도쿠 판처럼 숫자가 적힌 격자무늬 종이에 테트로미노를 배치해서, 테트로미노와 맞닿는 숫자의 합 중 최댓값을 찾으면 되는 문제다.

 마땅한 해결책이 떠오르지 않을 땐 브루트포스가 되는지부터 알아보자. 연산 횟수를 세면 된다. 보통 PS에서는 컴퓨터는 1초에 1억 번 연산을 할 수 있다는 불문율을 적용한다. 여기선 시간제한이 2초니 상한은 2억 번이 될 것이다.

 이제 최악의 경우에서 브루트포스를 할 때의 연산 횟수를 구하자.

 우선 $N$과 $M$의 최댓값은 $500$, 그리고 테트로미노의 블록 개수만큼 루프를 또 돌텐데, 크기가 제멋대로지만, 가장 긴 I 블록이 4칸을 잡으니, 대충 $4 \times 4$번 루프를 더 돈다고 생각하고 정도로 잡자.

 최대한 하한을 끌어올렸지만 7천만을 겨우 넘는다. 충분히 가능할 것 같다.

### 2. 표현
 브루트포스가 된다면 해법은 간단하다. '테트로미노'를 놓을 수 있는 곳마다 모두 놓고 합을 구한 뒤, 합의 최댓값을 구하면 되는 문제다.

 문제는 테트로미노의 모양을 어떻게 표현할 지에 관한 거다. 우선 회전이나 반전을 통해 만들 수 있는 테트로미노 모양이 몇 종류 있는지 세 보면 다음 그림과 같이 19 종류나 된다.

![](img/2.png)

각 모양마다 몇 가지 패턴이 있긴 하지만, 필자의 경우에는 그냥 모두 저장하는 쪽이 간단하게 보였다. 각 테트로미노를 어떻게 표현할 지만 정하면 되는데...

가장 무식한 방법인 2차원 배열로는...
```cpp
int tetromino[19][4][4] = {
    {{1, 1, 1, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}},
    {{1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}},
    ...
};
```

상상만 해도 끔찍하다. 물론 이 3차원 배열 코드를 만들어주는 프로그램을 만들어도 되지만, 귀찮은 건 매한가지다. 메모리-환경오염이기도 하고. 그러니 약간 더 Nerd스럽게 기교를 부려보도록 하자.

코드의 주석에 적혀있듯, 4x4 보드를 각각의 16비트에 대응시켜 16진수로 줄어들면 코드처럼 된다. 읽어들이는 것은 `&` 연산자와 `<<` 연산자를 이용하면 해결된다.

코드의 `xlenm1`과 `ylenm1`은 각각 테트로미노의 가로 길이와 세로 길이에서 1을 뺀(`m1`) 값이다. 이를 `m`, `n`에서 뺀 값이, 종이의 시작부터 끝까지 테트로미노가 삐져나오지 않고 돌 수 있는 범위다.

설명은 끝났다. 다시 한 번 코드를 읽어보자!

## 나가는 말
 그냥 3차원 노가다 할 걸 그랬나?