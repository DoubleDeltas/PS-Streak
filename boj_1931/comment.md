# 백준 1931: 회의실 배정
_Code: 20220503, Comment: 20220503, Last Edit: -_

## 들어가는 말

 중간고사와 하청의 크런치 때문에 잠시 느슨해졌다. 사실은 그동안 도전했던 문제가 있는데, 오늘에서야 드디어 해결했다.

 그리디 알고리즘 문제는 거의 처음이라 할 수 있겠다. 이 문제를 시작하면서 2가지 난관이 있었고 2가지 다 도움을 받아 해결해버렸는데,
 * 그리디 알고리즘은 '매 상황'에 따라 최적의 해를 찾는다. 이를 위해선 시각을 그 상황에 한해 국소적으로 좁혀야 한다는 점을 알지 못했다.
 * 회의가 시작하자마자 끝나는 경우에 대한 정렬 기준을 생각하지 못했다.

## 본문

이 문제는 그리디 알고리즘을 활용한 문제다. 그리디 알고리즘은 주어진 '현재 상황'에 대해 매 순간마다 최선의 선택을 하는 것이다. 그 결과가 최적의 해가 아닐 수도 있지만, 적어도 이 문제는 최적의 해를 보장한다.

그럼 잠시 문제 상황을 사고실험해보자. 현재 상황에 대해 선택을 하기 위해선 우선 그 현재 상황이라는 것이 있어야 하니깐 말이다. 시작은 시간이 0일 때부터 시작한다.

이때 회의를 최대한 많이 진행하기 위해서는, 앞으로 남은 회의들 중 최대한 일찍 끝나는 회의들만을 골라 진행하는 것이 최적으로 보인다.

이를 시뮬레이션 한 것이 코드의 `sort()`와 `while`문 부분이다. 일찍 끝나는 회의를 순서대로 고르기 위해, 끝나는 시간 순으로 정렬하고, 가장 가까운 것부터 차례차례 진행 후, 회의 시간에 맞추지 못한 회의들을 버리는 과정이다.

한편, 회의가 시작하자마자 끝나는 경우도 있다고 했다. 그러니, 예를 들면 `[4, 7], [7, 7]` 같은 회의가 있으면, 정렬했을 때도 이 순서를 유지해야 한다는 것이다. 그러므로 `sort()`의 비교 함수가 약간 복잡해졌다. 끝나는 시간이 같으면, 먼저 시작하는 것을 골라야 한다.

반례로, 그렇지 않아서 `time`이 `3`일 때 `[7, 7], [4, 7]`과 같이 정렬되어버렸다면, `[7, 7]`을 선택한 후 `time`은 `7`이 되고, 다음 회의인 `[4, 7]`는 넘겨버리기 때문에 정답이 나오지 않을 것이다. 어떤 반례인지는 모르지만, 실제 채점에서는 25% 정도에서 `시간 초과`를 받는다. 이 점이 필자를 헷갈리게 했다.

## 나가는 말

그리디 알고리즘 문제를 바라보는 관점을 조금은 이해하게 된 것 같다. 이에 대해 연습해볼 필요가 있겠다.