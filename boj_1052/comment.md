# 백준 1052: 물병
_Code: 20220510, Comment: 20220510, Last Edit: -_

## 들어가는 말

 저번 풀이 이후로 그리디 알고리즘을 찾다 발견했다. 막상 풀어보니 '이런 것도 그리디...?'라는 생각에 조금 당황했다.

## 본문
우선 문제의 조건에 의해
* '같은 물병' 2개만 선택하여 한 쪽에 몰아주므로, 물병을 1번 붓고 난 뒤에는 무조건 들이가 2배인 물병 1개와 빈 병이 나온다.
* 처음 주어진 물병과 새로 구입한 물병은 모두 1L의 물이 담겨있다.

위 두 조건을 조합하면, 각 물병은 항상 (2의 거듭제곱) L의 물이 들어 있으며, 만약 $P$ L의 물을 물병의 수를 최소한으로 해서 담았을 때 물병의 개수는

$$ P = \sum_{i=0} a_i 2^i \quad (a_i = 0 \text{ or }1)$$

꼴로 분해했을 때의 $a_i = 1$인 $i$의 개수, 즉, 이진수로 표현한 $P$의 1의 개수(OEIS [A000120](https://oeis.org/A000120))와 같다. 추가로, 해가 없는 경우는 존재하지 않는다.

물병의 개수를 구하는 방법을 알았다. 만약 물병의 개수가 $K$보다 크다면, 추가로 물병을 구입하고 다시 구하는 작업을 반복하고 난 후, 반복 횟수를 구하면 된다.

추가로 종료 조건에 관하여 알고리즘의 안전성을 검증해보자. 종료 조건이 가장 엄격한 케이스는 $K$가 최솟값 1일 때고 이때 종료될 수 있는 경우는 초기 물병과 구매한 물병의 개수 합(`n + buy`)이 2의 거듭제곱 꼴이었을 때다. $N$의 최댓값은 $10^7$이므로, 이 알고리즘은 이 숫자 이상의 2의 거듭제곱들 중 가장 작은 수, 즉, $2^{30} = 1073741824$를 넘지 않으므로 제한 시간 안에 반드시 해를 구할 것이다. (1초에 1억 번으로 추산하면)

## 나가는 말

조금 더 어려운 문제를 찾아보자.